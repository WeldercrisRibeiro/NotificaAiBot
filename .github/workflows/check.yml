name: Check Infarma CAB versions

on:
  schedule:
    - cron: "0 12 * * 1" # toda segunda 12:00 UTC (~09:00 Fortaleza)
  workflow_dispatch: {}  # bot√£o "Run workflow" (consultar na hora)

jobs:
  check:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout (needed for cache file)
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Run checker
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          BASE_URL: https://s3.amazonaws.com/infarma-cv/2504ba
        run: |
          node <<'NODE'
          const fs = require("fs");
          const https = require("https");

          const BASE_URL = process.env.BASE_URL;
          const TOKEN = process.env.TELEGRAM_BOT_TOKEN;
          const CHAT_ID = process.env.TELEGRAM_CHAT_ID;

          const PRODUCTS = {
            VmdRrd: "Varejo",
            VmdTrm: "Terminal",
            VmdPdv: "Caixa",
            VmdImpRlj: "Importa√ß√£o de dados Loja",
            VmdImp: "Importa√ß√£o de dados Central",
            VmdSrv: "Infarma Servi√ßo",
          };

          const STATE_FILE = ".state.json";

          // HEAD que N√ÉO derruba o job: sempre resolve com status
          function head(url) {
            return new Promise((resolve) => {
              const req = https.request(url, { method: "HEAD" }, (res) => {
                const etag = (res.headers.etag || "").toString();
                const lm = (res.headers["last-modified"] || "").toString();
                const len = Number(res.headers["content-length"] || 0);
                resolve({ status: res.statusCode || 0, etag, lm, len });
              });

              req.on("error", () => resolve({ status: 0, etag: "", lm: "", len: 0 }));
              req.end();
            });
          }

          function sendTelegram(text) {
            const payload = JSON.stringify({ chat_id: CHAT_ID, text });
            return new Promise((resolve, reject) => {
              const req = https.request(
                `https://api.telegram.org/bot${TOKEN}/sendMessage`,
                {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    "Content-Length": Buffer.byteLength(payload),
                  },
                },
                (res) => {
                  let data = "";
                  res.on("data", (c) => (data += c));
                  res.on("end", () => {
                    if (res.statusCode >= 200 && res.statusCode < 300) resolve(data);
                    else reject(new Error(data));
                  });
                }
              );
              req.on("error", reject);
              req.write(payload);
              req.end();
            });
          }

          async function main() {
            if (!TOKEN || !CHAT_ID) {
              throw new Error("Missing TELEGRAM_BOT_TOKEN/TELEGRAM_CHAT_ID secrets.");
            }

            const state = fs.existsSync(STATE_FILE)
              ? JSON.parse(fs.readFileSync(STATE_FILE, "utf8"))
              : {};

            const changes = [];

            for (const [key, name] of Object.entries(PRODUCTS)) {
              const url = `${BASE_URL}/${key}.CAB`;
              const info = await head(url);

              // Se n√£o existe, s√≥ pula (n√£o falha)
              if (info.status === 404) {
                console.log(`404 (n√£o existe): ${url}`);
                continue;
              }

              // Se der outro status (0, 500, etc), pula e loga
              if (info.status < 200 || info.status >= 400) {
                console.log(`Falhou status=${info.status}: ${url}`);
                continue;
              }

              const sig = `etag=${info.etag}|lm=${info.lm}|len=${info.len}`;
              const prev = state[key];

              // Primeira vez: s√≥ salva (n√£o avisa)
              if (!prev) {
                state[key] = sig;
                continue;
              }

              if (prev !== sig) {
                changes.push({ key, name, url, prev, sig, info });
                state[key] = sig;
              }
            }

            fs.writeFileSync(STATE_FILE, JSON.stringify(state, null, 2));

            if (changes.length === 0) {
              console.log("No changes.");
              return;
            }

            for (const c of changes) {
              const msg =
                `üÜï Nova vers√£o detectada!\n\n` +
                `Produto: ${c.name} (${c.key})\n` +
                `Link: ${c.url}\n\n` +
                `Antes: ${c.prev}\n` +
                `Agora:  ${c.sig}\n\n` +
                `Detalhes:\n` +
                `- ETag: ${c.info.etag}\n` +
                `- Last-Modified: ${c.info.lm}\n` +
                `- Size: ${c.info.len} bytes`;

              await sendTelegram(msg);
            }
          }

          main().catch((e) => {
            console.error(e);
            process.exit(1);
          });
          NODE

      - name: Commit state if changed
        run: |
          if git status --porcelain | grep -q ".state.json"; then
            git config user.name "github-actions"
            git config user.email "github-actions@github.com"
            git add .state.json
            git commit -m "Update state"
            git push
          else
            echo "No state changes to commit."
          fi